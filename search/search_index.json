{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"VisualAlgo VisualAlgo is a collection of algorithms and models intersecting the domains of computer vision and neuroscience. The repository is categorized based on the major tasks/stages in visual processing. Each category includes relevant algorithms from both computer vision and neuroscience. Disclaimer This repository is created purely for educational purposes. It contains implementations of algorithms that might be copyrighted or protected by other legal means. The goal is to showcase these implementations as a personal project and to facilitate learning. Please note that while you are welcome to browse and learn from this code, I highly discourage using it directly in any production system or for any commercial purposes, as it may infringe upon the rights of the original algorithm authors or patent holders. For each algorithm implemented, aside from those widely used and commonly known, I have included citations and references to the original papers where they were presented. Always be sure to respect the rights of the original creators and acknowledge their work. It is your responsibility to ensure that you have the proper legal permission to use any code or concept presented here. This code is provided \"as is\" and without any warranties. The author of this repository is not responsible for any consequences that may arise from your use of the code. Please also note that this repository is currently a work in progress and may contain bugs.","title":"Home"},{"location":"#visualalgo","text":"VisualAlgo is a collection of algorithms and models intersecting the domains of computer vision and neuroscience. The repository is categorized based on the major tasks/stages in visual processing. Each category includes relevant algorithms from both computer vision and neuroscience.","title":"VisualAlgo"},{"location":"#disclaimer","text":"This repository is created purely for educational purposes. It contains implementations of algorithms that might be copyrighted or protected by other legal means. The goal is to showcase these implementations as a personal project and to facilitate learning. Please note that while you are welcome to browse and learn from this code, I highly discourage using it directly in any production system or for any commercial purposes, as it may infringe upon the rights of the original algorithm authors or patent holders. For each algorithm implemented, aside from those widely used and commonly known, I have included citations and references to the original papers where they were presented. Always be sure to respect the rights of the original creators and acknowledge their work. It is your responsibility to ensure that you have the proper legal permission to use any code or concept presented here. This code is provided \"as is\" and without any warranties. The author of this repository is not responsible for any consequences that may arise from your use of the code. Please also note that this repository is currently a work in progress and may contain bugs.","title":"Disclaimer"},{"location":"pages/attention-and-search/","text":"8. Attention and Search Computer Vision Algorithms Selective Search Neuroscience Models Feature Integration Theory Biased Competition Model","title":"8. Attention and Search"},{"location":"pages/attention-and-search/#8-attention-and-search","text":"","title":"8. Attention and Search"},{"location":"pages/attention-and-search/#computer-vision-algorithms","text":"Selective Search","title":"Computer Vision Algorithms"},{"location":"pages/attention-and-search/#neuroscience-models","text":"Feature Integration Theory Biased Competition Model","title":"Neuroscience Models"},{"location":"pages/color-vision/","text":"7. Color Vision Computer Vision Algorithms Gamma Compression Neuroscience Models Opponent Process Models Retinex Theory","title":"7. Color Vision"},{"location":"pages/color-vision/#7-color-vision","text":"","title":"7. Color Vision"},{"location":"pages/color-vision/#computer-vision-algorithms","text":"Gamma Compression","title":"Computer Vision Algorithms"},{"location":"pages/color-vision/#neuroscience-models","text":"Opponent Process Models Retinex Theory","title":"Neuroscience Models"},{"location":"pages/depth-perception-and-3d-reconstruction/","text":"6. Depth Perception and 3D Reconstruction Computer Vision Algorithms Stereo Vision Struction from Motion (SfM), SLAM Image Stiching Neuroscience Models Binocular Disparity Models Motion Parallax Models","title":"6. Depth Perception and 3D Reconstruction"},{"location":"pages/depth-perception-and-3d-reconstruction/#6-depth-perception-and-3d-reconstruction","text":"","title":"6. Depth Perception and 3D Reconstruction"},{"location":"pages/depth-perception-and-3d-reconstruction/#computer-vision-algorithms","text":"Stereo Vision Struction from Motion (SfM), SLAM Image Stiching","title":"Computer Vision Algorithms"},{"location":"pages/depth-perception-and-3d-reconstruction/#neuroscience-models","text":"Binocular Disparity Models Motion Parallax Models","title":"Neuroscience Models"},{"location":"pages/feature-extraction/","text":"2. Feature Extraction Computer Vision Algorithms Canny Edge Detection Corner Detection Blob Detection SIFT SURF ORB HOG Neuroscience Models Simple and Complex Cell Models","title":"2. Feature Extraction"},{"location":"pages/feature-extraction/#2-feature-extraction","text":"","title":"2. Feature Extraction"},{"location":"pages/feature-extraction/#computer-vision-algorithms","text":"Canny Edge Detection Corner Detection Blob Detection SIFT SURF ORB HOG","title":"Computer Vision Algorithms"},{"location":"pages/feature-extraction/#neuroscience-models","text":"Simple and Complex Cell Models","title":"Neuroscience Models"},{"location":"pages/getting-started/","text":"Getting Started","title":"Getting Started"},{"location":"pages/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"pages/image-processing-and-enhancement/","text":"1. Image Pre-processing and Enhancement Computer Vision Algorithms Histogram Equalization Neuroscience Models Center-Surround Model","title":"1. Image Processing and Enhancement"},{"location":"pages/image-processing-and-enhancement/#1-image-pre-processing-and-enhancement","text":"","title":"1. Image Pre-processing and Enhancement"},{"location":"pages/image-processing-and-enhancement/#computer-vision-algorithms","text":"Histogram Equalization","title":"Computer Vision Algorithms"},{"location":"pages/image-processing-and-enhancement/#neuroscience-models","text":"Center-Surround Model","title":"Neuroscience Models"},{"location":"pages/learning-and-memory/","text":"9. Learning and Memory Computer Vision Algorithms Deep Learning Models (CNN, Autoencoders, GAN, Transformers) Neuroscience Models Hopfield Network Adaptive Resonance Theory (ART)","title":"9. Learning and Memory"},{"location":"pages/learning-and-memory/#9-learning-and-memory","text":"","title":"9. Learning and Memory"},{"location":"pages/learning-and-memory/#computer-vision-algorithms","text":"Deep Learning Models (CNN, Autoencoders, GAN, Transformers)","title":"Computer Vision Algorithms"},{"location":"pages/learning-and-memory/#neuroscience-models","text":"Hopfield Network Adaptive Resonance Theory (ART)","title":"Neuroscience Models"},{"location":"pages/matrix/","text":"VisualAlgo::Matrix Struct Documentation The Matrix struct provides a two-dimensional matrix object, along with numerous methods for performing operations on the matrix. Include #include \"helpers/matrix.hpp\" Struct Attributes rows ( int ): The number of rows in the matrix. cols ( int ): The number of columns in the matrix. data ( vector<vector<float>> ): A 2D vector that holds the matrix data. Constructors Matrix(int rows, int cols) : Constructs a new Matrix object with the given number of rows and columns. The matrix is initialized with all elements set to 0. VisualAlgo::Matrix m(3, 4); // Creates a 3x4 matrix with all elements initialized to 0 Matrix(int rows, int cols, float value) : Constructs a new Matrix object with the given number of rows and columns. The matrix is initialized with all elements set to the provided value. VisualAlgo::Matrix m(3, 4, 1.0); // Creates a 3x4 matrix with all elements initialized to 1.0 Matrix(vector<vector<float>> data) : Constructs a new Matrix object with the provided 2D vector data. std::vector<std::vector<float>> data = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}}; VisualAlgo::Matrix m(data); // Creates a 2x3 matrix with the provided data or VisualAlgo::Matrix m({{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}}); Matrix(const Matrix &other) : Copy constructor. Constructs a new Matrix object that is a copy of the provided matrix. VisualAlgo::Matrix m1(3, 4, 1.0); VisualAlgo::Matrix m2(m1); // Creates a new matrix that is a copy of m1 Element-wise Operations Element-wise operations perform the operation on each element of the matrix independently. Matrix &operator=(const Matrix &other) : Assignment operator. Copies the provided matrix to the current matrix. VisualAlgo::Matrix m1(3, 4, 1.0); VisualAlgo::Matrix m2 = m1; // m2 is now a copy of m1 Matrix operator+(const Matrix &other) : Adds the provided matrix to the current matrix. VisualAlgo::Matrix m1(2, 2, 1.0); VisualAlgo::Matrix m2(2, 2, 2.0); VisualAlgo::Matrix m3 = m1 + m2; // m3 is now a 2x2 matrix with all elements set to 3.0 Matrix operator+(const float &other) : Add the provided float to all entries. Also support other common arithmetic operators. Matrix Operations Matrix transpose() : Returns the transpose of the current matrix. VisualAlgo::Matrix m1(2, 3, 1.0); VisualAlgo::Matrix m2 = m1.transpose(); // m2 is now a 3x2 matrix float dot(const Matrix &other) : Calculates the dot product of the current matrix with the provided matrix. VisualAlgo::Matrix m1(3, 3, 1.0); VisualAlgo::Matrix m2(3, 3, 2.0); float result = m1.dot(m2); // result is now 18 Matrix Matrix::matmul(const Matrix &other) : Matrix multiplication. auto m1 = Matrix({{1, 2, 3}, {4, 5, 6}}); auto m2 = Matrix({{10, 11}, {20, 21}, {30, 31}}); auto m3 = m1.matmul(m2); Accessors void set(int row, int col, float value) : Sets the value at the specified row and column in the matrix. VisualAlgo::Matrix m(3, 4, 0.0); m.set(1, 2, 1.0); // Sets the value at row 1, column 2 to 1.0 const float get(int row, int col) const : Returns the value at the specified row and column in the matrix. VisualAlgo::Matrix m(3, 4, 1.0); float value = m.get(2, 3); // Gets the value at row 2, column 3 std::vector<float> &operator[](int row) : Returns the row at the specified index in the matrix. VisualAlgo::Matrix m(3, 4, 1.0); std::vector<float> row = m[1]; // Gets the second row of the matrix Statistics float sum() : Returns the sum of all elements in the matrix. VisualAlgo::Matrix m(2, 3, 1.0); float sum = m.sum(); // sum is now 6.0 float mean() : Returns the mean (average) of all elements in the matrix. VisualAlgo::Matrix m(2, 3, 1.0); float mean = m.mean(); // mean is now 1.0 Also supports std() , max() , and min() operations. Image Operations void Matrix::load(const std::string &filename) : This function loads an image from the specified file path and stores it as a grayscale matrix. The function can only handle images in PPM format (P6). If the file doesn't exist or the file format is not P6, it will throw a runtime error. VisualAlgo::Matrix m; m.load(\"path_to_your_image.ppm\"); // Loads the image from the specified path This function reads the image file as a binary file. It first reads the header to ensure that the image is in the correct format (P6), then reads the width and height of the image. The pixel data is then read and converted from RGB to grayscale using the ITU-R BT.709 luma transform. The grayscale pixel values are stored in the data member of the Matrix object. void Matrix::save(const std::string &filename, bool normalize) : This function saves the matrix as an image to the specified file path. The image is saved in PPM format (P6). The normalize parameter specifies whether the matrix data should be normalized to the range 0-255 before saving. If not normalized and the pixel values are not within this range, a runtime error is thrown. VisualAlgo::Matrix m(3, 4, 1.0); m.save(\"path_to_save_image.ppm\", true); // Normalizes and saves the matrix as an image to the specified path This function first checks if the data needs normalization based on the normalize flag. If true, it normalizes the data in the Matrix object to the range 0-255 using the normalize255() function. Then it writes the image data to the file in PPM format (P6). The pixel data is written as RGB, where the R, G, and B values are all equal, resulting in a grayscale image. void Matrix::normalize255() : This function normalizes the values in the matrix to the range 0-255. This is useful to prepare the data for saving as an image, since pixel values in an image must be in this range. VisualAlgo::Matrix m(3, 4, 1.0); m.normalize255(); // Normalizes the matrix values to the range 0-255 void Matrix::relu() : This function applies the ReLU (Rectified Linear Unit) operation to the matrix. It replaces all negative pixel values with zeros, effectively achieving half-wave rectification. VisualAlgo::Matrix m(3, 4, -1.0); m.relu(); // Changes all negative values to 0 Matrix Matrix::cross_correlation(const VisualAlgo::Matrix &kernel, int padding, int stride) const : This function performs the cross-correlation operation between the matrix and the provided kernel. The padding and stride parameters control the operation. If the kernel size is larger than the matrix or the stride is less than or equal to zero, or padding is negative, it will throw an invalid_argument exception. VisualAlgo::Matrix m(3, 4, 1.0); VisualAlgo::Matrix kernel(2, 2, 0.5); VisualAlgo::Matrix result = m.cross_correlation(kernel, 1, 2); // Perform cross-correlation This function creates an output matrix of appropriate size based on the input matrix, kernel, padding and stride. It then performs the cross-correlation operation and stores the result in the output matrix.","title":"Matrix"},{"location":"pages/matrix/#visualalgomatrix-struct-documentation","text":"The Matrix struct provides a two-dimensional matrix object, along with numerous methods for performing operations on the matrix.","title":"VisualAlgo::Matrix Struct Documentation"},{"location":"pages/matrix/#include","text":"#include \"helpers/matrix.hpp\"","title":"Include"},{"location":"pages/matrix/#struct-attributes","text":"rows ( int ): The number of rows in the matrix. cols ( int ): The number of columns in the matrix. data ( vector<vector<float>> ): A 2D vector that holds the matrix data.","title":"Struct Attributes"},{"location":"pages/matrix/#constructors","text":"Matrix(int rows, int cols) : Constructs a new Matrix object with the given number of rows and columns. The matrix is initialized with all elements set to 0. VisualAlgo::Matrix m(3, 4); // Creates a 3x4 matrix with all elements initialized to 0 Matrix(int rows, int cols, float value) : Constructs a new Matrix object with the given number of rows and columns. The matrix is initialized with all elements set to the provided value. VisualAlgo::Matrix m(3, 4, 1.0); // Creates a 3x4 matrix with all elements initialized to 1.0 Matrix(vector<vector<float>> data) : Constructs a new Matrix object with the provided 2D vector data. std::vector<std::vector<float>> data = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}}; VisualAlgo::Matrix m(data); // Creates a 2x3 matrix with the provided data or VisualAlgo::Matrix m({{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}}); Matrix(const Matrix &other) : Copy constructor. Constructs a new Matrix object that is a copy of the provided matrix. VisualAlgo::Matrix m1(3, 4, 1.0); VisualAlgo::Matrix m2(m1); // Creates a new matrix that is a copy of m1","title":"Constructors"},{"location":"pages/matrix/#element-wise-operations","text":"Element-wise operations perform the operation on each element of the matrix independently. Matrix &operator=(const Matrix &other) : Assignment operator. Copies the provided matrix to the current matrix. VisualAlgo::Matrix m1(3, 4, 1.0); VisualAlgo::Matrix m2 = m1; // m2 is now a copy of m1 Matrix operator+(const Matrix &other) : Adds the provided matrix to the current matrix. VisualAlgo::Matrix m1(2, 2, 1.0); VisualAlgo::Matrix m2(2, 2, 2.0); VisualAlgo::Matrix m3 = m1 + m2; // m3 is now a 2x2 matrix with all elements set to 3.0 Matrix operator+(const float &other) : Add the provided float to all entries. Also support other common arithmetic operators.","title":"Element-wise Operations"},{"location":"pages/matrix/#matrix-operations","text":"Matrix transpose() : Returns the transpose of the current matrix. VisualAlgo::Matrix m1(2, 3, 1.0); VisualAlgo::Matrix m2 = m1.transpose(); // m2 is now a 3x2 matrix float dot(const Matrix &other) : Calculates the dot product of the current matrix with the provided matrix. VisualAlgo::Matrix m1(3, 3, 1.0); VisualAlgo::Matrix m2(3, 3, 2.0); float result = m1.dot(m2); // result is now 18 Matrix Matrix::matmul(const Matrix &other) : Matrix multiplication. auto m1 = Matrix({{1, 2, 3}, {4, 5, 6}}); auto m2 = Matrix({{10, 11}, {20, 21}, {30, 31}}); auto m3 = m1.matmul(m2);","title":"Matrix Operations"},{"location":"pages/matrix/#accessors","text":"void set(int row, int col, float value) : Sets the value at the specified row and column in the matrix. VisualAlgo::Matrix m(3, 4, 0.0); m.set(1, 2, 1.0); // Sets the value at row 1, column 2 to 1.0 const float get(int row, int col) const : Returns the value at the specified row and column in the matrix. VisualAlgo::Matrix m(3, 4, 1.0); float value = m.get(2, 3); // Gets the value at row 2, column 3 std::vector<float> &operator[](int row) : Returns the row at the specified index in the matrix. VisualAlgo::Matrix m(3, 4, 1.0); std::vector<float> row = m[1]; // Gets the second row of the matrix","title":"Accessors"},{"location":"pages/matrix/#statistics","text":"float sum() : Returns the sum of all elements in the matrix. VisualAlgo::Matrix m(2, 3, 1.0); float sum = m.sum(); // sum is now 6.0 float mean() : Returns the mean (average) of all elements in the matrix. VisualAlgo::Matrix m(2, 3, 1.0); float mean = m.mean(); // mean is now 1.0 Also supports std() , max() , and min() operations.","title":"Statistics"},{"location":"pages/matrix/#image-operations","text":"void Matrix::load(const std::string &filename) : This function loads an image from the specified file path and stores it as a grayscale matrix. The function can only handle images in PPM format (P6). If the file doesn't exist or the file format is not P6, it will throw a runtime error. VisualAlgo::Matrix m; m.load(\"path_to_your_image.ppm\"); // Loads the image from the specified path This function reads the image file as a binary file. It first reads the header to ensure that the image is in the correct format (P6), then reads the width and height of the image. The pixel data is then read and converted from RGB to grayscale using the ITU-R BT.709 luma transform. The grayscale pixel values are stored in the data member of the Matrix object. void Matrix::save(const std::string &filename, bool normalize) : This function saves the matrix as an image to the specified file path. The image is saved in PPM format (P6). The normalize parameter specifies whether the matrix data should be normalized to the range 0-255 before saving. If not normalized and the pixel values are not within this range, a runtime error is thrown. VisualAlgo::Matrix m(3, 4, 1.0); m.save(\"path_to_save_image.ppm\", true); // Normalizes and saves the matrix as an image to the specified path This function first checks if the data needs normalization based on the normalize flag. If true, it normalizes the data in the Matrix object to the range 0-255 using the normalize255() function. Then it writes the image data to the file in PPM format (P6). The pixel data is written as RGB, where the R, G, and B values are all equal, resulting in a grayscale image. void Matrix::normalize255() : This function normalizes the values in the matrix to the range 0-255. This is useful to prepare the data for saving as an image, since pixel values in an image must be in this range. VisualAlgo::Matrix m(3, 4, 1.0); m.normalize255(); // Normalizes the matrix values to the range 0-255 void Matrix::relu() : This function applies the ReLU (Rectified Linear Unit) operation to the matrix. It replaces all negative pixel values with zeros, effectively achieving half-wave rectification. VisualAlgo::Matrix m(3, 4, -1.0); m.relu(); // Changes all negative values to 0 Matrix Matrix::cross_correlation(const VisualAlgo::Matrix &kernel, int padding, int stride) const : This function performs the cross-correlation operation between the matrix and the provided kernel. The padding and stride parameters control the operation. If the kernel size is larger than the matrix or the stride is less than or equal to zero, or padding is negative, it will throw an invalid_argument exception. VisualAlgo::Matrix m(3, 4, 1.0); VisualAlgo::Matrix kernel(2, 2, 0.5); VisualAlgo::Matrix result = m.cross_correlation(kernel, 1, 2); // Perform cross-correlation This function creates an output matrix of appropriate size based on the input matrix, kernel, padding and stride. It then performs the cross-correlation operation and stores the result in the output matrix.","title":"Image Operations"},{"location":"pages/motion-analysis-and-tracking/","text":"5. Motion Analysis and Tracking Computer Vision Algorithms Optical Flow Background Subtraction Kalman Filter CAMShift Neuroscience Models Reichardt Detectors Motion Energy Models","title":"5. Motion Analysis and Tracking"},{"location":"pages/motion-analysis-and-tracking/#5-motion-analysis-and-tracking","text":"","title":"5. Motion Analysis and Tracking"},{"location":"pages/motion-analysis-and-tracking/#computer-vision-algorithms","text":"Optical Flow Background Subtraction Kalman Filter CAMShift","title":"Computer Vision Algorithms"},{"location":"pages/motion-analysis-and-tracking/#neuroscience-models","text":"Reichardt Detectors Motion Energy Models","title":"Neuroscience Models"},{"location":"pages/object-detection-and-recognition/","text":"4. Object Detection and Recognition Computer Vision Algorithms Viola-Jones R-CNN SSD YOLO Haar Cascades Neuroscience Models HMAX Model","title":"4. Object Detection and Recognition"},{"location":"pages/object-detection-and-recognition/#4-object-detection-and-recognition","text":"","title":"4. Object Detection and Recognition"},{"location":"pages/object-detection-and-recognition/#computer-vision-algorithms","text":"Viola-Jones R-CNN SSD YOLO Haar Cascades","title":"Computer Vision Algorithms"},{"location":"pages/object-detection-and-recognition/#neuroscience-models","text":"HMAX Model","title":"Neuroscience Models"},{"location":"pages/segmentation-and-grouping/","text":"3. Segmentation and Grouping Computer Vision Algorithms Region Growing Watershed K-means Clustering Mean Shift GrabCut U-Net Region Proposal Network (RPN) Neuroscience Models FBF Model Grossberg and Wyse, Figure-Ground Separation of Connected Scenic Figures: Boundaries, Filling-In, and Opponent Processing. Neural Networks For Vision and Image Processing , Chapter 7., 1992. (Paper on the same topic, but with bad scan quality) Explanation: The nerual network model is part of a larger pattern recongition model. It is responsible for the early processing step, up to the figure-ground separation step. It is made up of Feature Contour System (FCS) and the Boundary Contou System (BCS) proposed by Grossberg and Mingolla (1985). Because the sequence of processing is FCS-BCS-FCS, the model is named FCS networks. Note that FCS and BCS are characterize by the behavior. The models evolved to be very complex these days, and the exact implementation is often based on papers. The algorithm is broken up into 4 steps: * CONFIGR (Carpenter, Gaddam, and Mingolla, 2007) Paper Tolerance Space Theory (TST) for Gestalt Proximity Principle (Peng, Yang, and Li, 2021) Paper Gestalt Laws Models Border Ownership Models","title":"3. Segmentation and Grouping"},{"location":"pages/segmentation-and-grouping/#3-segmentation-and-grouping","text":"","title":"3. Segmentation and Grouping"},{"location":"pages/segmentation-and-grouping/#computer-vision-algorithms","text":"","title":"Computer Vision Algorithms"},{"location":"pages/segmentation-and-grouping/#region-growing","text":"","title":"Region Growing"},{"location":"pages/segmentation-and-grouping/#watershed","text":"","title":"Watershed"},{"location":"pages/segmentation-and-grouping/#k-means-clustering","text":"","title":"K-means Clustering"},{"location":"pages/segmentation-and-grouping/#mean-shift","text":"","title":"Mean Shift"},{"location":"pages/segmentation-and-grouping/#grabcut","text":"","title":"GrabCut"},{"location":"pages/segmentation-and-grouping/#u-net","text":"","title":"U-Net"},{"location":"pages/segmentation-and-grouping/#region-proposal-network-rpn","text":"","title":"Region Proposal Network (RPN)"},{"location":"pages/segmentation-and-grouping/#neuroscience-models","text":"","title":"Neuroscience Models"},{"location":"pages/segmentation-and-grouping/#fbf-model","text":"Grossberg and Wyse, Figure-Ground Separation of Connected Scenic Figures: Boundaries, Filling-In, and Opponent Processing. Neural Networks For Vision and Image Processing , Chapter 7., 1992. (Paper on the same topic, but with bad scan quality) Explanation: The nerual network model is part of a larger pattern recongition model. It is responsible for the early processing step, up to the figure-ground separation step. It is made up of Feature Contour System (FCS) and the Boundary Contou System (BCS) proposed by Grossberg and Mingolla (1985). Because the sequence of processing is FCS-BCS-FCS, the model is named FCS networks. Note that FCS and BCS are characterize by the behavior. The models evolved to be very complex these days, and the exact implementation is often based on papers. The algorithm is broken up into 4 steps: *","title":"FBF Model"},{"location":"pages/segmentation-and-grouping/#configr-carpenter-gaddam-and-mingolla-2007","text":"Paper","title":"CONFIGR (Carpenter, Gaddam, and Mingolla, 2007)"},{"location":"pages/segmentation-and-grouping/#tolerance-space-theory-tst-for-gestalt-proximity-principle-peng-yang-and-li-2021","text":"Paper","title":"Tolerance Space Theory (TST) for Gestalt Proximity Principle (Peng, Yang, and Li, 2021)"},{"location":"pages/segmentation-and-grouping/#gestalt-laws-models","text":"","title":"Gestalt Laws Models"},{"location":"pages/segmentation-and-grouping/#border-ownership-models","text":"","title":"Border Ownership Models"},{"location":"pages/stimulus/","text":"VisualAlgo::Stimulus Namespace Documentation The VisualAlgo::Stimulus namespace provides functions to create stimuli in the form of 2D matrices and add noise to them. Include #include \"helpers/stimulus.hpp\" #include \"helpers/matrix.hpp\" Functions Matrix random_mondrian(int rows, int cols, int num_rectangles); Creates a new Matrix object with the given number of rows and cols , and draws a specified number of random overlapping rectangles in it. Each rectangle has a random position and size, and a random value in the range [0, 1]. Returns the new Matrix . VisualAlgo::Stimulus::Matrix matrix = random_mondrian(10, 10, 10); void add_noise(Matrix &matrix, float noise_probability); Randomly changes some percentage of pixels in the given matrix to any value in the range [0, 1]. noise_probability is the fraction of pixels that will be changed. It must be a value between 0 and 1. VisualAlgo::Stimulus::Matrix matrix = random_mondrian(10, 10, 10); add_noise(matrix, 0.1); This creates a 10x10 matrix with 10 randomly placed squares, and then adds noise to 10% of the pixels.","title":"Stimulus"},{"location":"pages/stimulus/#visualalgostimulus-namespace-documentation","text":"The VisualAlgo::Stimulus namespace provides functions to create stimuli in the form of 2D matrices and add noise to them.","title":"VisualAlgo::Stimulus Namespace Documentation"},{"location":"pages/stimulus/#include","text":"#include \"helpers/stimulus.hpp\" #include \"helpers/matrix.hpp\"","title":"Include"},{"location":"pages/stimulus/#functions","text":"Matrix random_mondrian(int rows, int cols, int num_rectangles); Creates a new Matrix object with the given number of rows and cols , and draws a specified number of random overlapping rectangles in it. Each rectangle has a random position and size, and a random value in the range [0, 1]. Returns the new Matrix . VisualAlgo::Stimulus::Matrix matrix = random_mondrian(10, 10, 10); void add_noise(Matrix &matrix, float noise_probability); Randomly changes some percentage of pixels in the given matrix to any value in the range [0, 1]. noise_probability is the fraction of pixels that will be changed. It must be a value between 0 and 1. VisualAlgo::Stimulus::Matrix matrix = random_mondrian(10, 10, 10); add_noise(matrix, 0.1); This creates a 10x10 matrix with 10 randomly placed squares, and then adds noise to 10% of the pixels.","title":"Functions"}]}